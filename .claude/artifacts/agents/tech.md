# 기술 타당성 분석 — 수학 문제 레벨링 품질 검증

## 1. 기술 타당성 평가

### 1.1 핵심 알고리즘 분석

수학 난이도 채점 기준표는 **6가지 가중치(W1~W6)를 합산하여 W_총점을 산출**하고, 이를 3단계 변환(W_총점 → W → C)을 거쳐 최종 난이도 레벨을 결정하는 구조이다.

**가중치 체계:**

| 가중치 | 명칭 | 범위 | 핵심 로직 |
|--------|------|------|----------|
| W1 | 연산 종류 및 방향성 | 0 ~ +1.5 | 덧셈 0점, 뺄셈 +1.5점 |
| W2 | 자릿수와 자릿값 | 0 ~ +4 | 동일 0점, 비대칭 +1.0, 확장 시 자릿당 +2.0 |
| W3 | 숫자 요소 인지 부하 | 0 ~ +1.5 | 6~9 포함 시 개당 +0.5 (최대 1.5) |
| W4 | 절차적 복잡성 | 0 ~ +5.0 | No Carry 0, Single +3.0, Double +5.0 |
| W5 | 특수 숫자 (감점) | -1.5 ~ 0 | 10의 배수 -1.0, 동일 반복 -0.5 |
| W6 | 표현 방식 및 문맥 | 0 ~ +0.5 | 단순 수식형 0점 (현재 데이터 기준 +0.5 고정) |

**W_총점 공식:** `W_총점 = W1 + W2 + W3 + W4 + W5 + W6`

- 이론적 범위: -1.5 ~ 12.5 (실측 범위: 0 ~ 11)
- W4(절차적 복잡성)가 0~5점으로 가장 넓은 범위를 가지며, **난이도 변별의 핵심 축**이다.

### 1.2 3단계 변환 파이프라인

```
W_총점 (0~11) ──→ W 스케일 (1~23) ──→ C 레벨 (1~15)
   합산값           선형 근사 변환        비선형 조건부 매핑
```

**변환 1 (W_총점 → W):** 데이터 분석 결과 `W ≈ W_총점 × 2 + 1` 패턴이 관찰되나, 정확한 수식은 원본 문서에 명시되어 있지 않다. 역공학을 통한 정밀 매핑 테이블 구축이 필요하다.

**변환 2 (W → C):** 비선형 매핑이며, **동일 W값에서도 연산 유형과 결과값 범위에 따라 C가 달라진다.** 예를 들어 W=18에서 덧셈은 C=8~11, 뺄셈은 C=13~14로 분기한다. 이는 단순 테이블 변환이 아닌 조건부 분기 로직이 필요함을 의미한다.

### 1.3 데이터 규모 및 특성

- **현재 데이터셋**: ~15,000건 (0~99 범위, 덧셈/뺄셈)
- **데이터 형식**: CSV (16개 컬럼)
- **전수 사전 계산**: 모든 문제-가중치-레벨이 이미 확정됨
- **확장 시 규모 추정**:
  - 곱셈/나눗셈 추가: ~60,000건 (4배)
  - 3자리 수 확장: ~2,000,000건 (133배)
  - 혼합 연산: 조합 폭발 가능

### 1.4 타당성 판정: **구현 가능 (HIGH)**

현재 범위(0~99, 덧셈/뺄셈)에 대해서는 사전 계산 룩업 테이블로 완전 구현 가능하다. W1~W6 가중치 계산 규칙이 결정론적이며, 모든 입력-출력 매핑이 데이터로 검증 가능하다.

---

## 2. 아키텍처 개요

### 2.1 권장 아키텍처: 하이브리드 (룩업 + 실시간 계산)

```
┌─────────────────────────────────────────────────┐
│                   API Gateway                    │
│              (REST / GraphQL)                    │
├──────────────┬──────────────────────────────────┤
│   Lookup     │      Calculation Engine          │
│   Service    │   (Stateless Functions)           │
│  (Phase 1)   │      (Phase 2)                   │
├──────────────┼──────────────────────────────────┤
│              │                                   │
│  Pre-computed│   W1~W6 Calculator               │
│  Table (DB)  │   W→C Mapper                     │
│  ~15K rows   │   Carry/Borrow Detector          │
│              │   Special Number Checker          │
│              │                                   │
├──────────────┴──────────────────────────────────┤
│              Data Layer                          │
│   PostgreSQL / Redis Cache                       │
└─────────────────────────────────────────────────┘
```

### 2.2 Phase 1: 룩업 테이블 서비스

- CSV 데이터를 RDB(PostgreSQL)에 적재
- `(operand1, operator, operand2)` → `(W1~W6, W_total, W_scale, C_level)` 즉시 반환
- 인덱스: `(operator, operand1, operand2)` 복합 인덱스
- 응답 시간 목표: < 5ms (캐시 히트 시 < 1ms)

### 2.3 Phase 2: 실시간 계산 엔진

확장(곱셈/나눗셈, 3자리 수) 대비 실시간 가중치 계산 엔진:

```
Input: (operand1: int, operator: string, operand2: int)
  │
  ├─ W1 Calculator: operation_type → score
  ├─ W2 Calculator: digit_count_diff(op1, op2) → score
  ├─ W3 Calculator: count_digits_above_5(op1, op2) → score
  ├─ W4 Calculator: simulate_carry_borrow(op1, operator, op2) → score
  ├─ W5 Calculator: detect_special_patterns(op1, op2, result) → score
  └─ W6 Calculator: expression_type → score (metadata input)
  │
  ├─ W_total = sum(W1..W6)
  ├─ W_scale = transform_to_W(W_total)  // 역공학 필요
  └─ C_level = map_to_C(W_scale, operator, result_range)  // 조건부 분기
```

### 2.4 Shadow Mode 전환 전략

Phase 2 개발 완료 후, 룩업 결과와 실시간 계산 결과를 동시에 산출하여 100% 일치를 확인한 뒤 전환한다.

---

## 3. 주요 기술 의사결정

### 결정 1: 사전 계산 vs 실시간 계산

| 기준 | 사전 계산 (Phase 1) | 실시간 계산 (Phase 2) |
|------|-------------------|---------------------|
| 정확성 | 원본 데이터 그대로 (100%) | 역공학 수식 의존 (검증 필요) |
| 확장성 | 데이터 추가 시 재적재 필요 | 수식만 추가하면 즉시 지원 |
| 성능 | DB 조회 (< 5ms) | 계산 (< 10ms) |
| 유지보수 | 데이터 파일 관리 | 코드 로직 관리 |

**결정**: Phase 1에서 사전 계산 테이블로 시작하고, 확장 요구 시 Phase 2 실시간 엔진으로 전환한다.

### 결정 2: W→C 매핑 구현 방식

**결정**: 현재 15,000건 전수 데이터에서 (W, operator, result_range) → C 매핑 규칙을 역공학으로 추출한다. Decision tree 또는 룩업 테이블로 구현하되, 모든 케이스에 대해 원본 데이터와 100% 일치 테스트를 수행한다.

### 결정 3: 데이터 저장 형식

**결정**: CSV → PostgreSQL 마이그레이션. 컬럼 매핑:

| CSV 컬럼 | DB 컬럼 | 타입 |
|----------|---------|------|
| 문제 | expression | VARCHAR |
| 정답 | answer | INTEGER |
| W1_연산 ~ W6_표현 | w1 ~ w6 | DECIMAL(3,1) |
| W_총점 | w_total | DECIMAL(4,1) |
| W(1~23) | w_scale | INTEGER |
| C(1~15) | c_level | INTEGER |

### 결정 4: Carry/Borrow 감지 알고리즘

**결정**: 자릿수별 덧셈/뺄셈 시뮬레이션으로 Carry/Borrow를 감지한다.

```python
def detect_carry_borrow(op1, operator, op2):
    if operator == '+':
        carries = 0
        for digit_pos in range(max_digits):
            d1 = digit_at(op1, digit_pos)
            d2 = digit_at(op2, digit_pos)
            if d1 + d2 + carry_in >= 10:
                carries += 1
        return carries  # 0: 없음, 1: Single, 2+: Double/Continuous
    elif operator == '-':
        borrows = 0
        for digit_pos in range(max_digits):
            d1 = digit_at(op1, digit_pos)
            d2 = digit_at(op2, digit_pos)
            if d1 - borrow_in < d2:
                borrows += 1
        return borrows
```

---

## 4. 통합 포인트 (외부 시스템)

### 4.1 학습 관리 시스템 (LMS) 연동

- **API 인터페이스**: REST API로 난이도 조회 엔드포인트 제공
  - `GET /api/v1/difficulty?expression=2+8` → C_level, W_scale, W1~W6 상세
  - `POST /api/v1/difficulty/batch` → 배치 조회 (최대 1000건)
- **인증**: API Key 또는 OAuth 2.0

### 4.2 문제 은행 시스템

- **입력**: 문제 은행에서 문제 메타데이터(연산자, 피연산자) 수신
- **출력**: 난이도 레벨(C) 및 상세 가중치 반환
- **동기화**: 문제 은행 업데이트 시 난이도 재계산 트리거

### 4.3 적응형 학습 엔진

- **이벤트 기반**: 학습자 정답/오답 결과를 수신하여 레벨링 정확도 피드백 루프 구성
- **A/B 테스트**: 가중치 파라미터 변경 시 실험 그룹별 다른 C 레벨 제공

### 4.4 데이터 파이프라인

```
Google Drive (CSV) ──→ ETL Pipeline ──→ PostgreSQL ──→ API Service
                       (Python/dbt)      (Primary)      (FastAPI)
                                            │
                                         Redis (Cache)
```

---

## 5. 비기능 요구사항

### 5.1 성능

| 메트릭 | 목표값 | 비고 |
|--------|--------|------|
| 단건 조회 응답 시간 | < 10ms (p95) | 캐시 히트 시 < 1ms |
| 배치 조회 (1000건) | < 500ms (p95) | 병렬 처리 |
| 동시 접속 | 1,000 RPS | 학교 수업 시간 피크 |
| 데이터 적재 시간 | < 30초 | 15,000건 CSV → DB |

### 5.2 보안

- API 인증: API Key 필수, Rate Limiting (IP당 100 RPS)
- 데이터 암호화: TLS 1.3 (전송 중), AES-256 (저장 시)
- 접근 제어: RBAC (관리자 / 교사 / 시스템)
- 감사 로그: 모든 난이도 조회/변경 기록

### 5.3 확장성

| 단계 | 데이터 규모 | 아키텍처 |
|------|-----------|---------|
| Phase 1 | ~15,000건 | 단일 DB + 캐시 |
| Phase 2 | ~60,000건 | 실시간 계산 + DB 폴백 |
| Phase 3 | ~2,000,000건 | 분산 계산 + 파티셔닝 |

### 5.4 가용성

- SLA: 99.9% (월간 다운타임 < 43분)
- 헬스체크: `/health` 엔드포인트 + DB 연결 확인
- 장애 대응: 룩업 서비스 장애 시 캐시 서빙, 계산 엔진 폴백

### 5.5 데이터 무결성

- CSV 파싱 시 필드 수(16개), 타입, 범위 검증
- W_총점 = W1+W2+W3+W4+W5+W6 재계산 검증 (모든 행)
- W5 음수값 부호 검증 (-1.0, -0.5)
- C 레벨 범위 검증 (1~15)
- CI/CD 파이프라인에 전수 검증 테스트 통합

---

## 부록: 핵심 데이터 패턴

### W_총점 분포 (관측값)

| W_총점 | W 스케일 | 대표 문제 |
|--------|---------|----------|
| 0 | 1 | 0+0, 1+1, 2+2 (기초 덧셈) |
| 0.5 | 2 | 0+1, 1+0 (한 자리 덧셈, 작은 수) |
| 1.5 | 4 | 0-0, 1-1 (기초 뺄셈) |
| 2.5 | 6 | 0+10, 10+1 (두 자리 수 포함 덧셈) |
| 4 | 9 | 2+8=10 (올림 발생 덧셈) |
| 7 | 15 | 1+19=20 (올림+두 자리 덧셈) |
| 8.5 | 18 | 60-11=49 (빌림+두 자리 뺄셈) |
| 11 | 23 | 99+98=197 (최고 난이도 덧셈) |

### C 레벨 변별 요인

1. **연산 유형**: 뺄셈이 덧셈보다 높은 C 레벨 (W1=+1.5 효과)
2. **올림/빌림**: W4가 0→3→5로 점프하며 C 레벨에 가장 큰 영향
3. **자릿수**: 한 자리→두 자리 전환 시 W2=+3~4로 C 레벨 급등
4. **특수 숫자 감점**: 10의 배수, 동일 반복 시 C 레벨 하향 조정
